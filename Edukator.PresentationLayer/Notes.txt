-N Tier Architecture (N Katmanlý Mimari) Avantajlarý ;
	* Hata yönetimini kolaylaþtýrýr.
	* Eriþilebilirlik kolaylaþýr.
	* Kod tekrarý azalýr.
	* Sürdürülebilirlik ve projede büyük çaplý deðiþimler kolaylaþýr.
	* Güvenlik artar.

-N katmanlý mimaride temel olarak 4 katman bulunmaktadýr. Bunlar;
	* Entity Layer
	* Data Access Layer
	* Business Layer
	* Presentation Layer
- Projenin büyüklüðüne göre baþka katmanlar da eklenebilir. Bunlara birkaç örnek olarak;
	* Api için katman
	* Data Transfer object Layer 

-Entity layer: Bu katmanda tablolar ve sütunlar tutulur.
-Data Access Layer: Bu katmanda CRUD iþlemleri yapýlýr.
-Business Layer: Bu katmanda yetki kontrolleri ve validasyon kontrolleri yapýlýr.
-Presentation Layer: Bu katmanda arayüz bulunur. UI iþlemleri yapýlýr.

-Code First yapýsý: Projedeki database iþlemlerinin hepsi kod tarafýnda yapýlýr. Sql bu durumda sadece bir Veri Tabaný dýr. 
- Katmanlarda iki tane temel dosya oluþturulur. Concrete ve Abstract. Concrete klasörü içinde projede bulunacak sýnýflar tutulur. Abstract da ise projede bulunacak interfaceler tutulur.

-Access Modifier (Eriþim Belirleyiciler): Temel de 4 tane vardýr. Bunlar;
	-Public: Her yerden eriþilebilmesini saðlar.
	-Private: Sadece bulunduðu class veya interface den içinde eriþilebilir.
	-internal: Sadece bulunduðu katmandan eriþim saðlanýr.
	-protected: Bulunduðu sýnýf ve bu sýnýfý miras alan sýnýflar eriþebilir.

-Katmanlý mimari projelerinde katmanlar içinde sýnýflar tek baþýna oluþturulmaz. Katmanlar içinde klasörler oluþturulur. Oluþan klasörlerde sýnýflar oluþturulur. Bu sebeple projede default oluþan sýnýflarý sildik.

-Code First de Sýnýflar-->Tablolara, Propertyler ise Sütunlara dönüþür.

	Code First de db oluþturmak için ihtiyacýmýz olan paketler;
-EntityFramework Core: EF ile ilgili iþlemleri yapar.
-EntityFramework Tools:Migration iþlemlerini gerçekleþtirmemizi saðlar.
-EntityFramework Design:Migration iþlemlerini gerçekleþtirmemizi saðlar.
-Sql Server: Sql Server'ý kullanmamý saðlar.

-Migration: Göç anlamýna gelir. Verileri Visual Studio dan Sql Server'a taþýmamýzý saðlar.

-DAL Katmanýndaki Concrete klasöründe;
	* Entityler, baðlantý adresleri tutulur.
-DAL Katmanýndaki Abstract klasöründe;
	* Interfaceler tutulur.

-DbContext Sýnýfý: EF de bazý method ve özellikleri kullanmamý saðlayan bir sýnýf.

			---------------REFERANSLAR------------
-Referans Verme: Referans aldýðýn katmanýn içindeki sýnýf ,method ya da özelliklerini kullanmak amacýyla referans verilir.

-Katmanlar En temel katmandan ileriye doðru sýrasýyla aþadaki gibidir;

* EntityLayer:En temel katmandýr. Tüm katmanlar bu katmana eriþebilir. 
* DataAccessLayer : Bu katman sadece Business da ve presentation katmanlarýnda kullanýlabilir.       
* BusinessLayer: Bu katman da sadece Presentation katmanýnda kullanýlabilir.      
* PresentationLayer: Bu katmana yukarýdaki 3 katman da diðer katmanlarda eklenebilir. Baþka bir katmana referans edilemez!

-Katmanda Referans Nasýl Verilir: Referans ekleyeceðiniz katmanýn üzerine sað týk ise Add>Project Reference seçilerek istenilen katman eklenebilir.

-Migration Ekleme: Migration eklenen consol için View>Other Windows>Package Manager Console seçilmeli

- NOTT: Migration oluþturulmadan önce gelen ekrandaki Default Project kýsmýna database baðlantý adresi hangi katmanda ise o katmanýn alana seçilmesi gerekir.

- add-migration migration_adý : Migration eklemeye yarar.
- update-database: Bu ise eklenen migration'ý db de gözükmesi için

- NOT: Migration isimleri genelde yaptýðý isimleri nitelemeli. Boþ isimler olmamalý, anlaþýlýr olmalý!

- Repository Design Pattern: Bir tasarým desenidir. Projede yapýlacak CRUD iþlemlerinin arka planda tutulmasý için generic yapýda oluþturulup kalýtýlarak kullanýlmayý saðlar.
 
 -Business katmanýnda validasyon kurallarý kontrolü saðlanýr.
 -Business katmanýndaki interfaceler (Abstract klasörü içinde) Service olarak adlandýrýyor,
 sýnýflar(Concrete klasörü içinde) ise Manager olarak tanýmlanýr. Genel olarak bu þekilde oluþturuluyor.

 -Dependency Injection: Classlar arasýnda baðýmlýlýðý en aza indirmek için kullanýlan programlama tekniðidir.

					Projedeki akýþýn genel özeti
1- Entity katmanýnda Concrete klasörü altýnda entityler tanýmlanýr.
2-Data Access katmaný içindeki Concrete klsörü içinde Context sýnýfý oluþturarak sqlconnection ve entity katmanýnda oluþturduðum sýnýflar dbset de tanýmlanýr.
3-Context içinde entityler tanýmlandýktan sonra migration ile db ye tablolar oluþturulur.
4-Data Access katmaný içindeki Abstract klasörü altýnda Generic bir interface oluþturulur.
5-Data Access katmaný içindeki Abstract klasörü altýnda entitylere özel interfaceler oluþturularak generic interface miras alýnýr.
6- Data Access katmaný içindeki Repositories klasörü altýnda Generic Repository design paterni ile CRUD iþlemleri için Generic bir class oluþturulur.
7- Oluþturulan sýnýf Data Access katmanýndaki Abstract klasöründe oluþturduðumuz generic interface'i kalýtým yapar ve O interface içindeki methodlarý sýnýfa implemente ederek doldurur.
8-Data Access Layer katmanýnda Repositories klasöründe genericrepo sýnýfý bittikten sonra ayný katmanda Entity Framework klasöründe her entity'e özel sýnýf oluþturularak Repositories klasöründeki sýnýf ile kalýtým yapar.
9-Business katmanýndaki Abstract klasöründe Generic bir interface servisi oluþturulur ve Data Access katmanýndaki Abstract klasöründeki generic interface içindeki methodlar kopyalanarak baþýna bir T harfi konur.(Diðer katman ile karýþmamasý için!)
10- Business daki Abstract klasöründe Generic interface servisi oluþturduktan sonra her entity için bir interface servisi oluþturulup generic interface servisinden miras alýnýr.
11-Business katmanýndaki Abstract da servisler kurulduktan sonra ayný katmanda Concrete klasöründe de her entity'e özel Manager sýnýflar oluþturulur ve Generic interface servisinden miras alýnarak oradaki methodlar o sýnýflara implemente edilir.
12- Oluþturulan manager sýnýfýnda o entity'nin Data Access katmanýndaki interface inden nesne oluþturularak oradaki methodlar kullanýlýr.
13- Presentation katmanýna gelip oluþturulan controllerlarda istenilen entity'e ait Business katmanýndaki Service çaðýrýlýr.





An unhandled exception occurred while processing the request.
InvalidOperationException: Unable to resolve service for type 'Edukator.BusinessLayer.Abstract.ICategoryService' while attempting to activate 'Edukator.PresentationLayer.Controllers.CategoryController'. HATASI:

Bu hatanýn sebebi, Constructor uygulanan sýnýflarýn arka tarafta (Startup.cs de ConfigureServices methodunda) çaðýrýlmasý gerekli!


- asp-for özelliði: Asp.Net MVC de Html.Helper, Asp.Net Core da tek helperlar vardýr. Genelde inputlar ile kullanýlýyor. View de tanýmladýðýn modele ait alanlara ulaþýþabiliyor.

-textarea tag'ý: View tarafýnda kullanýlýr. Uzun birkaç satýrlýk açýklamalar için text yerine kullanýlabilir. Bu tag içinde rows özelliði kaç satýr maks yazman gerektiðini belirlemeni saðlar.

-Asp.Net Core da iliþkili tablolardaki alanlarý view de görüntüleyebilmek için iliþkili tabloya view de direk eriþerek o tablodaki deðeri getiremezsin. 
Örnek: <td>@item.Category.CategoryName</td> (Bu .Net FrameWork de geçerli bir kullaným!)

-Asp.Net Core da ise bu þekilde iliþkili tablolardaki verileri view kýsmýnda görüntüleyebilmek için 'include' methodunu kullanman gerekiyor.
Include methodu sana birden fazla iliþkili olan alanlarý view kýsmýnda getirmeni saðlar.
EfCourseDal.cs içinde örnek bulunmakta!

-Bir interface'e interface kalýtým yaparken kalýtým yaptýðýnýz interface içindeki methodlarý implemente etmeniz gerekmiyor, ama bir sýnýfa bir interface kalýtým yaptýðýnda o interface içindeki methodlarý kalýtým yaptýðýnýz sýnýfta implemente etmek zorundasýnýz!

-OrderByDescending(): EF'in bir methodudur. Kayýtlarý z-a 'ya sýralar.
-Take():Ef'in bir methodudur. Verdiðin koþuldaki kayýtlardan kaç tane kayýt dönmesi gerektiðini belirtir.


- Identity:Microsoft tarafýndan geliþtirilmiþ bir kütüphanedir. Register, Login ve roll iþlemlerini kolaylýkla yapmayý saðlayan bir kütüphanedir.
Oturum açma iþlemleri için bu kütüphane kullanýlýr. Bu kütüphaneyi Presentation,Entity ve Data Access katmanlarýna identity için gerekli paketleri yüklüyorum.

-Gerekli Paketler: * Microsoft.AspNetCore.Identity , * Microsoft.AspNetCore.Identity.EntityFrameworkCore
-Paketler katmanlara yüklendikten sonra DataAccess katmanýnda Context sýnýfýndaki miras olan DbContext sýnýfý yerine IdentityDbContext sýnýfý miras alýnýr. Zaten bu sýnýfýn içinde de DbContext sýnýfý miras alýyor.
-Sonrasýnda ise package console dan yeni bir migration oluþturulur ve db güncellenir. Sonrasýnda AspNet.Identity ile db ye 7 tane ekstra tablo yüklenir. Bunlar;
	*AspNetRoles
	*AspNetUsers
	*AspNetRoleClaims
	*AspNetUserClaims
	*AspNetUserLogins
	*AspNetUserRoles
	*AspNetUserTokens

-Package console da migration eklemeden önce DataAccess katmanýný seçmemizin nedeni, DbContext veya IdentityDbContext sýnýfýný o katmanda kullandýðýmýzdan dolayý!
-Ýdentity kütüphanesi ile gelen tablolarý kaldýrmak için Context sýnýfýnda tekrar DbContext den miras alarak migration eklemelisiniz.
-Ýdentity ile gelen tablolardan AspNetUsers tablosunda gelen alanlara ben de ekstra kendi istediðim alanlarý da eklemek istersem bunun için þu þekilde yapabilirim;
	-Eklemek istediðim alanlarý entity katmanýnda sýnýf olarak oluþturur ve alanlarý içerisine yazarým o sýnýfý da IdentityUser sýnýfýndan miras aldýrarak hem AspNetUsers tablosundaki alanlar hemde benim eklemek istediðim alanlar bir tablo içerisinde olur.

-[StringLength(100)]: Bu entity katmanýnda property eklenirken üstüne konulan bir attribüt dür. DataAnnotation namespace'i ile gelir. Bunun altýna yazdýðýn property'nin kaç karakter olduðunu bu attribüt ile belirleyebilirsin. Örneðin 100 gibi.

-DbContext mirasý ile entity de oluþturulan string bir property db ye default olarak max karakter olarak kayýt edilir. IdentityDbContext ile miras alýnan entity deki string deðiþkenli property ise default 256 karakter olarak db ye kayýt edilir.

-IdentityDbContext ile gelen 7 tablodan AspNetUsers ile AspNetRoles tablolarýndaki id alanlarý default string gelmektedir. Bu alanlarýn deðiþken tipini int deðiþkenine dönüþtürmek için AspNetUsers için IdentityUser class'ýný miras olarak kullandýðým AppUser da ve IdentityUser'ý miras alýrken þu þekilde kullanmalýyým (IdentityUser<int>)
AspNetRoles için de bu id alanýnýn int olmasý için bir entity katmanýnda class oluþturup sonrasýnda da IdentityRole sýnýfý ile miras almalýyým(IdentityRole<int>)
Sonrasýnda Context de IdentityDbContext miras alýrken de ilk parametreye AspNetUser'ý miras aldýðým class'ý (AppUser), ikinci parametrede ise AspNetRoles tablosunu miras aldýðým sýnýfý(AppRole) sýnýfý son parametrede ise primary alanlarýnýn hangi deðiþken olmasý gerektiðini belirtip migration oluþturmalýyým.

NOT: IdentityDbContext ile gelen diðer tablolardaki id alanlarý için de benzer örnekler yapýp IdentityDbContext'in 3. overload'ýnda tek tek tüm tablolarý yazarak id alanlarýný int'e çevrilebilir!

										----------- SOLID-----------
SOLID, yazýlým geliþtirmede daha esnek, bakým yapýlabilir ve geniþletilebilir kod yazmayý amaçlayan beþ temel tasarým ilkesinin baþ harflerinden oluþan bir akronimdir. SOLID ilkeleri, Robert C. Martin (Uncle Bob) tarafýndan tanýmlanmýþtýr ve nesne yönelimli programlama (OOP)'da yazýlým tasarým kalitesini artýrmayý amaçlar.

Her bir ilkenin açýklamasý þu þekildedir:

1. S - Single Responsibility Principle (Tek Sorumluluk Ýlkesi)
Her sýnýfýn yalnýzca bir sorumluluðu olmalýdýr. Baþka bir deyiþle, bir sýnýf yalnýzca tek bir iþ yapmalý ve o iþi tam olarak yerine getirmelidir. Bu sayede sýnýfýn deðiþiklik gerektiren tek bir sebebi olur.

Örnek: Eðer bir sýnýf hem dosya okuma iþini yapýyor hem de verileri iþleyip analiz ediyorsa, bu ilke ihlal edilmiþ olur. Bu durumda, dosya okuma iþlemi bir sýnýfta, veri iþleme ise baþka bir sýnýfta yapýlmalýdýr.
2. O - Open/Closed Principle (Açýk/Kapalý Ýlkesi)
Yazýlým bileþenleri (sýnýflar, modüller, fonksiyonlar vb.) geniþletilmeye açýk ama deðiþtirilmeye kapalý olmalýdýr. Yani, bir sýnýfa yeni bir davranýþ eklemek için sýnýfý deðiþtirmek yerine, sýnýfý geniþleterek (inheritance veya polymorphism kullanarak) yeni iþlevsellik eklenmelidir.

Örnek: Bir Payment sýnýfý varsa ve farklý ödeme türleri eklemek isteniyorsa, var olan sýnýfý deðiþtirmek yerine yeni bir ödeme türü ekleyen alt sýnýflar oluþturulmalýdýr.
3. L - Liskov Substitution Principle (Liskov'un Yerine Geçme Ýlkesi)
Bir alt sýnýf, her zaman türetilmiþ olduðu üst sýnýfýn yerine geçebilmelidir. Yani, üst sýnýfýn kullanýldýðý her yerde alt sýnýf da sorunsuzca kullanýlabilmelidir. Alt sýnýf, üst sýnýfýn davranýþlarýný bozacak þekilde davranmamalýdýr.

Örnek: Bir Animal üst sýnýfý varsa ve bir Bird alt sýnýfý oluþturulmuþsa, her Bird nesnesi, Animal nesnesinin kullanýldýðý her yerde kullanýlabilir olmalýdýr. Ancak, Bird sýnýfý uçma yeteneði eklerken Animal'ýn temel kurallarýný ihlal etmemelidir.
4. I - Interface Segregation Principle (Arayüz Ayrýmý Ýlkesi)
Sýnýflar, ihtiyacý olmayan iþlevlere sahip büyük ve geniþ arayüzler (interface) yerine, kendileri için gerekli olan özelleþmiþ küçük arayüzleri kullanmalýdýr. Baþka bir deyiþle, bir sýnýfýn gereksiz iþlevlere sahip bir arayüzü uygulamamasý gerekir.

Örnek: Bir sýnýf IMultiFunctionDevice (yazýcý, tarayýcý, faks gibi çok iþlevli cihaz) arayüzünü uygulamak yerine, IPrinter, IScanner, IFax gibi küçük ve spesifik arayüzleri uygulamalýdýr. Böylece, sadece ihtiyacý olan iþlevleri kullanmýþ olur.
5. D - Dependency Inversion Principle (Baðýmlýlýklarýn Ters Çevrilmesi Ýlkesi)
Üst düzey modüller (yüksek seviye sýnýflar), alt düzey modüllere doðrudan baðýmlý olmamalýdýr. Bunun yerine her iki modül de soyutlamalara (abstractions) baðýmlý olmalýdýr. Yani, kod baðýmlýlýklar üzerinde deðil, arayüzler veya soyut sýnýflar üzerinde çalýþmalýdýr.

Örnek: Bir UserService sýnýfý doðrudan bir EmailService'e baðýmlý olmamalýdýr. Bunun yerine bir IMessageService arayüzüne baðýmlý olmalýdýr, böylece farklý mesajlaþma yöntemleri (SMS, e-posta, vb.) kolayca eklenebilir.




